'use client'

import type { Prettify } from '@noaignite/types'
import type { RefObject } from 'react'
import type { GestureOptions } from './useGesture'
import { useGesture } from './useGesture'

/** Properties to extract from `useGesture` for re-use in this hook. */
type GestureProperties =
  | 'when'
  | 'axis'
  | 'deadZone'
  | 'onGestureStart'
  | 'onGestureMove'
  | 'onGestureEnd'

export type DragScrollOptions = Prettify<
  Pick<GestureOptions, GestureProperties> & {
    /**
     * When `true`, enable additional inerttial movement after the gesture ends.
     *
     * @defaultValue true
     */
    inertia?: boolean
  }
>

let rAF: number | null = null

type ApplyInertia = (element: Element, mX: number, mY: number) => void

const applyInertia: ApplyInertia = (element, mX, mY) => {
  if (rAF !== null) cancelAnimationFrame(rAF)

  const duration = 1600
  const ease = (t: number) => 1 - Math.pow(1 - t, 5)

  const step = (timestamp: number, startTime: number) => {
    const elapsed = timestamp - startTime
    const timeFraction = Math.min(elapsed / duration, 1)
    const easeValue = ease(timeFraction)

    const nextX = Math.round(mX * (1 - easeValue))
    const nextY = Math.round(mY * (1 - easeValue))

    element.scrollBy(-nextX, -nextY)

    const { scrollLeft, scrollTop } = element
    const { scrollWidth, scrollHeight, clientWidth, clientHeight } = element
    const maxScrollLeft = scrollWidth - clientWidth
    const maxScrollTop = scrollHeight - clientHeight

    if (
      (nextX === 0 && nextY === 0) ||
      (scrollLeft === 0 && scrollTop === 0) ||
      (Math.abs(scrollLeft) === maxScrollLeft && Math.abs(scrollTop) === maxScrollTop)
    ) {
      rAF = null
      return
    }

    if (timeFraction < 1) {
      requestAnimationFrame((timeAtStep) => {
        step(timeAtStep, startTime)
      })
    } else {
      rAF = null
    }
  }

  rAF = requestAnimationFrame((timestamp) => {
    step(timestamp, timestamp)
  })
}

/**
 * Enables a scrollable `ref` to be scrolled using drag gestures generated by a traditional mouse.
 *
 * @param ref - The element to attach the gesture to.
 * @param options - Configurable options
 *
 * @returns void
 *
 * @example
 * ```tsx
 * const ref = useRef<HTMLDivElement>(null)
 *
 * useDragScroll(ref);
 *
 * return <div ref={ref} />
 * ```
 */
export const useDragScroll = (
  ref: RefObject<Element | null>,
  {
    when = true,
    axis,
    deadZone = 3,
    onGestureStart,
    onGestureMove,
    onGestureEnd,
    inertia = true,
  }: DragScrollOptions = {},
) => {
  useGesture(ref, {
    when,
    axis,
    pointerType: 'mouse',
    deadZone,
    onGestureStart,
    onGestureMove: (event) => {
      const { movementX, movementY } = event

      const element = ref.current
      if (!element) return

      element.setAttribute('inert', 'true')

      element.scrollTop -= movementY
      element.scrollLeft -= movementX

      onGestureMove?.(event)
    },
    onGestureEnd: (event) => {
      onGestureEnd?.(event)

      const element = ref.current
      if (!element) return

      element.removeAttribute('inert')

      if (!inertia) return
      const { movementX, movementY } = event
      applyInertia(element, movementX, movementY)
    },
  })
}
